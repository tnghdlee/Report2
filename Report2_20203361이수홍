N = 5 # 집합 A = {1, 2, 3, 4, 5}의 크기
# 입출력 함수
def print_matrix(matrix, title=""):
    if title:
        print(title)
    for row in matrix:
        print(" ".join(map(str, row)))

# 관계 행렬 입력
def get_matrix():
    matrix = []
    print(f"각 행의 숫자 5개를 공백으로 구분하여 입력하세요 (예: 1 0 1 0 0).")
    
    for i in range(N):
        while True:
            try:
                row_input = input(f"{i+1}행 입력: ")
                row = [int(x) for x in row_input.split()]
                
                if len(row) != N:
                    print(f"오류: 정확히 {N}개의 숫자를 입력해야 합니다.")
                elif not all(x in [0, 1] for x in row):
                    print("오류: 0 또는 1만 입력해야 합니다.")
                else:
                    matrix.append(row)
                    break 
            except ValueError:
                print("오류: 유효한 숫자를 입력하세요.")
    return matrix

# 관계 성질 판별
def is_reflexive(matrix):
    for i in range(N):
        if matrix[i][i] == 0:
            return False
    return True

def is_symmetric(matrix):
    for i in range(N):
        for j in range(i + 1, N):
            if matrix[i][j] != matrix[j][i]:
                return False
    return True

def is_transitive(matrix):
    for i in range(N):
        for j in range(N):
            for k in range(N):
                if matrix[i][j] == 1 and matrix[j][k] == 1:
                    if matrix[i][k] == 0:
                        return False
    return True

#관계 합성 R² 행렬 계산 함수
def get_composition_R2(matrix):
    R2_matrix = [[0 for _ in range(N)] for _ in range(N)]
    for i in range(N):
        for j in range(N):
            for k in range(N):
                if matrix[i][k] == 1 and matrix[k][j] == 1:
                    R2_matrix[i][j] = 1
                    break 
    return R2_matrix

def is_transitive_v2(matrix, r2_matrix):
    for i in range(N):
        for j in range(N):
            if r2_matrix[i][j] == 1:
                if matrix[i][j] == 0:
                    return False 
    return True 

# 동치류 출력
def get_equivalence_classes(matrix):
    elements = list(range(1, N + 1))
    print("\n--- 동치류 출력 ---")

    for i in range(N):
        element = elements[i]
        equiv_class = set()
        
        for j in range(N):
            if matrix[i][j] == 1:
                equiv_class.add(elements[j]) 
        
        print(f"[{element}] = {sorted(list(equiv_class))}")

# 폐포 생성 함수
def reflexive_closure(matrix):
    closure = [row[:] for row in matrix]
    for i in range(N):
        if closure[i][i] == 0:
            closure[i][i] = 1
    return closure

def symmetric_closure(matrix):
    closure = [row[:] for row in matrix]
    for i in range(N):
        for j in range(i + 1, N):
            if closure[i][j] != closure[j][i]:
                closure[i][j] = 1
                closure[j][i] = 1
    return closure

def transitive_closure(matrix):
    closure = [row[:] for row in matrix]
    for k in range(N):
        for i in range(N):
            for j in range(N):
                if closure[i][k] == 1 and closure[k][j] == 1:
                    closure[i][j] = 1
    return closure

# main 실행문
def main():
    R = get_matrix()
    print_matrix(R, "\n--- 입력된 관계 행렬 R ---")

    R2 = get_composition_R2(R)
    print_matrix(R2, "\n--- 관계 합성 행렬 R² ---")

    r = is_reflexive(R)
    s = is_symmetric(R)
    t = is_transitive(R)       
    t2 = is_transitive_v2(R, R2) # (R² ⊆ R)

    print("\n--- 관계 성질 판별 결과 ---")
    print(f"1. 반사 관계 (Reflexive): {'O' if r else 'X'}")
    print(f"2. 대칭 관계 (Symmetric): {'O' if s else 'X'}")
    print(f"3. 추이 관계 (k-i-j 방식): {'O' if t else 'X'}")
    print(f"4. 추이 관계 (R² ⊆ R 검증): {'O' if t2 else 'X'}")

    is_equivalence = r and s and t 

    if is_equivalence:
        print("\n>> 결과: 입력된 관계는 동치 관계입니다.")
        get_equivalence_classes(R)
        
    else:
        print("\n>> 결과: 입력된 관계는 동치 관계가 아닙니다.")
        
        print("\n--- 동치 관계 폐포 생성 시작 ---")
        current_matrix = [row[:] for row in R] 

        if not r:
            print("\n1) 반사 관계가 아니므로 반사 폐포 r(R)를 생성합니다.")
            print("--- 변환 전 r(R) ---"); print_matrix(current_matrix)
            current_matrix = reflexive_closure(current_matrix)
            print("--- 변환 후 r(R) ---"); print_matrix(current_matrix)
        
        if not s:
            print(f"\n2) 대칭 관계가 아니므로 대칭 폐포 s(R)를 생성합니다.")
            print("--- 변환 전 s(R) ---"); print_matrix(current_matrix)
            current_matrix = symmetric_closure(current_matrix)
            print("--- 변환 후 s(R) ---"); print_matrix(current_matrix)

        if not is_transitive(current_matrix): 
            print(f"\n3) 추이 관계가 아니므로 추이 폐포 t(R)를 생성합니다.")
            print("--- 변환 전 t(R) (Warshall 적용 전) ---"); 
            print_matrix(current_matrix)
            current_matrix = transitive_closure(current_matrix)
            print("--- 변환 후 t(R) (Warshall 적용 후) ---"); 
            print_matrix(current_matrix)

        print("\n--- 모든 폐포 적용 후 최종 관계 판별 ---")
        r_final = is_reflexive(current_matrix)
        s_final = is_symmetric(current_matrix)
        t_final = is_transitive(current_matrix)

        print(f"1. 반사 관계 (Reflexive): {'O' if r_final else 'X'}")
        print(f"2. 대칭 관계 (Symmetric): {'O' if s_final else 'X'}")
        print(f"3. 추이 관계 (Transitive): {'O' if t_final else 'X'}")

        if r_final and s_final and t_final:
            print("\n>> 최종 결과: 생성된 폐포는 동치 관계입니다.")
            get_equivalence_classes(current_matrix)
        else:
            print("\n>> 최종 결과: 오류. 폐포 생성 후에도 동치 관계가 아닙니다.")

# 프로그램 시작
if __name__ == "__main__":
    main()
